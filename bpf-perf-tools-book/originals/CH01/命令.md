```bash
uname -a
Linux cccmmf 6.2.0-39-generic #40~22.04.1-Ubuntu SMP PREEMPT_DYNAMIC Thu Nov 16 10:53:04 UTC 2 x86_64 x86_64 x86_64 GNU/Linux
```



```bash
iostat

# 显示 CPU 使用情况
iostat -c
# 输出结果
# 平均 CPU 使用率	 用户空间程序占用 CPU 的百分比	优先级较高的用户空间程序占用 CPU 的百分比		系统内核占用CPU的百分比	CPU等待I/O操作完成的百分比。	被虚拟机偷取的 CPU 时间百分比	空闲百分比

# 显示磁盘使用情况
iostat -d

# 指定刷新时间和次数
iostat -c 2 5  # 每2秒输出一次，共输出5次

# 显示 CPU 指令统计
sudo perf stat -e instructions ls		# 统计ls总指令条数，总运行时间，用户/内核空间运行时间

# 显示 CPU 使用热点
sudo perf top

# 跟踪函数调用
perf record -e cycles -g -p <PID>
perf report

id		# 查看当前用户信息

funccount		# 统计函数执行的次数
sudo funccount-bpfcc 'vfs_*'	# 统计vfs_开头的所有函数的执行次数

strace chmod 600 1.txt	# 跟踪chmod执行的系统调用
strace -e trace=fchmodat  chmod 600 1.txt

# 对运行的代码进行采样
profile
sudo profile-bpfcc
sudo profile-bpfcc -p 1234	# 显示进程（PID为1234）的执行时间和函数调用次数等信息。

# BCC工具支持更多的输出内容，执行时可以带不同参数，bpftrace工具通常比较简单，功能单一，只做一件事
execsnoop					# 跟踪每个新创建的进程，通过跟踪 execve 系统调用工作
sudo execsnoop-bpfcc
sudo execsnoop-bpfcc -t		# 输出中增加时间戳信息
sudo./execsnoop				# 在bpftrace/tools下，有语法错误，笔者已经对其修复
man execsnoop

biolatency					# 它可以绘制块设备IO（disk I/O）的延迟直方图
sudo biolatency-bpfcc -m	# -m使得统计值以毫秒为单位输出 报错kprobe不存在，应该是我的新版本内核函数名变了
sudo ./biolatency.bt		# 在bpftrace/tools下，有语法错误，笔者已经对其修复
sudo ./biolatency-kp.bt

# bpftrace跟踪open()，如下是一个单行命令，跟踪open
sudo bpftrace -e 'tracepoint:syscalls:sys_enter_open { printf("%s %s\n", comm, str(args->filename)); }'
# 输出结果是进程的名字和传递给open系统调用的文件名

# 列出open系统调用和其变体系统调用
sudo bpftrace -l 'tracepoint:syscalls:sys_enter_open*'

# 统计open和其变体执行的次数
sudo bpftrace -e 'tracepoint:syscalls:sys_enter_open* { @[probe] = count(); }'

# 使用opensnoop跟踪open和openat
sudo opensnoop-bpfcc
sudo opensnoop-bpfcc -x		# 只显示打开文件失败的信息
sudo opensnoop-bpfcc -h 	# 查看支持的参数
# BCC版本的opensnoop支持更多参数，bpftrace工具通常比较简单，功能单一，只做一件事，BCC工具运行模式也比较多。比如可以通过修改bpftrace版本的opensnoop工具只显示失败的open系统调用，而BCC版本则通过命令行参数-x支持这一功能
# 也可以调用opensnoop.bt，在/bpftrace/tools下，不过opensnoop.bt不支持额外参数，只有单一的一个功能，而bcc的工具支持的参数比较多，
sudo ./opensnoop.bt		# 报错，有语法错误，笔者已经对其修复
```

