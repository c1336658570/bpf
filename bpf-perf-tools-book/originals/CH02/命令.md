```bash
tcpdump -d		# 可以打印出使用过滤器表达式的BPF指令
tcpdump -d host 127.0.0.1 and port 80

bitehist 		# 用直方图形式展现磁盘I/O的尺寸分布
sudo ./bcc/examples/tracing/bitehist.py

bitesize-bpfcc		# 跟踪块 I/O 操作的大小，并生成相应的分布直方图。

bpftool				# 默认输出展示了它所操作的BPF对象类型

# 每一类对象都有专门的帮助文档，对于prog对象如下：
bpftool prog help

# 对map如下：
bpftool map help

sudo bpftool perf		# perf子命令显示了哪些BPF程序正在通过perf_event_open()进行挂载，可以先运行execsnoop然后再运行该命令测试

sudo bpftool prog show		# 列出全部程序（不只是基于perf_event_open）

sudo bpftool prog dump xlated id 234	# 将BPF指令翻译为汇编指令打印出来，如果带BPF信息（调试信息）的话，输出会比不带BTF的多，不止包含BPF指令

# 如果程序中包含BTF信息（调试信息），那么可以使用linum修饰符在输出中增加源代码文件和行信息
sudo bpftool prog dump xlated id 263 linum

# 如果程序中包含BTF信息（调试信息），使用opcodes修饰符可以在输出中包含BPF指令的opcode(BPF指令对应的二进制数字)
sudo bpftool prog dump xlated id 263 opcodes

# 修饰符visual，可以以DOT格式输出控制流信息，支持用外部可视化软件打开，如下使用的是Graph Viz软件和他的绘制有向图工具dot
# 使用 bpftool 工具以可视化格式(visual)获取 BPF 程序 ID 为 263 的翻译版本（xlated）的信息，并将其输出保存到文件 biolatency_done.dot 中。
sudo bpftool prog dump xlated id 263 visual > biolatency_done.dot
# 使用 Graphviz 工具中的 dot 命令，将 biolatency_done.dot 文件转换为 PNG 格式的图像文件。选项 -Tpng 指定输出格式为 PNG，-Elen=2.5 设置边缘长度为 2.5（在图中表示两个节点之间的距离），最后 -o biolatency_done.png 将结果保存到文件 biolatency_done.png 中。
dot -Tpng -Elen=2.5 biolatency_done.dot -o biolatency_done.png
firefox biolatency_done.png 

sudo bpftool prog dump jited id 263	#prog dump jited子命令显示经过JIT编译之后的机器码（mov，xor，add等），如果有BTF，则可以包含源代码相应行信息，否则不会有任何相关输出
# 查看是否启动jit
grep CONFIG_BPF_JIT /boot/config-$(uname -r)
cat /proc/sys/net/core/bpf_jit_enable		# 输出为1表示启动

sudo bpftool btf show			# 打印所有btf信息
sudo bpftool btf dump id 5		# 打印BTF中的类型和结构信息(包括指针，结构体等)

# tcpdump -d可以输出BPF指令，bpftrace -v也可以达到同样目的（书上这么说的，但是是错误的，bpftrace -v会显示更详细信息，并不能输出BPF指令）
sudo bpftrace -v biolatency.bt

sudo strace -ebpf execsnoop-bpfcc		# 显示execsnoop-bpfcc使用了哪些bpf系统调用

# 多线程对映射表查找和更新可能造成一个线程破坏另一个线程的数据。这称为丢失的更新，是由于当前读和写发生了重叠造成的。使用per-cpu的哈希和数组映射类型，尽可能避免冲突问题
# 使用per-cpu哈希映射计数
sudo strace -febpf bpftrace -e 'k:vfs_read { @ = count(); }'
# 使用普通哈希映射计数
sudo strace -febpf bpftrace -e 'k:vfs_read { @++; }'
# 在一个8cpu系统同时运行上面两个程序
sudo bpftrace -e 'k:vfs_read { @cpuhash = count(); @hash++; }'
#对比结果发现，普通哈希会丢失0.01%的统计值

#vfsstat对VFS接口中的关键调用进行插桩，每秒打印概要信息
sudo vfsstat-bpfcc
grep attach_ 03vfsstat.py		# 查看vfsstat的挂载点

# 单行程序通过匹配'vfs_'开头的函数，统计了所有VFS函数的调用次数：
sudo bpftrace -e 'kprobe:vfs_* { @[probe] = count() }'

# 先打开一个终端，然后用gdb -p pid挂上，然后在gdb内使用disas readline反汇编readline函数，然后通过如下对readline()进行插桩
sudo bpftrace -e 'uprobe:/bin/bash:readline { @ = count() }'
# 然后再使用disas readline反汇编，查看第一条指令

# gethostlatency工具利用对库函数getaddrinfo和gethostbyname的插桩对主机名解析（DNS）访问进行跟踪
sudo gethostlatency-bpfcc
grep attach_ 04gethostlatency.py		# 查看挂载点

# 统计libc系统库中gethost函数的调用次数
sudo bpftrace -l 'uprobe:/lib/x86_64-linux-gnu/libc.so.6:gethost*'
sudo bpftrace -e 'uprobe:/lib/x86_64-linux-gnu/libc.so.6:gethost* { @[probe] = count(); }'

# 对每个跟踪点都会有一个对应的格式文件，例如：
# 查看tracepoint中的/syscalls/sys_enter_fchmodat的ebpf程序可以获取哪些信息
sudo cat /sys/kernel/debug/tracing/events/syscalls/sys_enter_fchmodat/format
# 查看tracepoint中的sched/sched_process_exec的格式信息
sudo cat /sys/kernel/debug/tracing/events/sched/sched_process_exec/format

# 查看所有跟踪点目录，每个跟踪点目录下有具体的跟踪点，可以向这些目录下的文件中写入内容开启或关闭跟踪点
sudo ls /sys/kernel/debug/tracing/events

tcplife		# 会为每个TCP会话打印一行摘要信息，其中包含各种细节信息
sudo tcplife-bpfcc

# 对sched:sched_process_exec进行插桩，此程序会将exec()的进程名打印出来
sudo bpftrace -e 'tracepoint:sched:sched_process_exec { printf("exec by %s\n", comm); }'

# 使用usdt
sudo bpftrace -e 'usdt:/tmp/tick:loop { printf("got: %\n", arg0); }'
```

